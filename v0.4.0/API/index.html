<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · NonuniformFFTs</title><meta name="title" content="API · NonuniformFFTs"/><meta property="og:title" content="API · NonuniformFFTs"/><meta property="twitter:title" content="API · NonuniformFFTs"/><meta name="description" content="Documentation for NonuniformFFTs."/><meta property="og:description" content="Documentation for NonuniformFFTs."/><meta property="twitter:description" content="Documentation for NonuniformFFTs."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NonuniformFFTs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">NonuniformFFTs.jl</a></li><li><a class="tocitem" href="../accuracy/">Accuracy</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Creating-plans"><span>Creating plans</span></a></li><li><a class="tocitem" href="#Setting-non-uniform-points"><span>Setting non-uniform points</span></a></li><li><a class="tocitem" href="#Executing-plans"><span>Executing plans</span></a></li><li><a class="tocitem" href="#Other-functions"><span>Other functions</span></a></li><li><a class="tocitem" href="#Available-spreading-kernels"><span>Available spreading kernels</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/NonuniformFFTs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/master/docs/src/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Creating-plans"><a class="docs-heading-anchor" href="#Creating-plans">Creating plans</a><a id="Creating-plans-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-plans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.PlanNUFFT" href="#NonuniformFFTs.PlanNUFFT"><code>NonuniformFFTs.PlanNUFFT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PlanNUFFT([T = ComplexF64], dims::Dims; ntransforms = Val(1), kwargs...)</code></pre><p>Construct a plan for performing non-uniform FFTs (NUFFTs).</p><p>The created plan contains all data needed to perform NUFFTs for non-uniform data of type <code>T</code> (<code>ComplexF64</code> by default) and uniform data with dimensions <code>dims</code>.</p><p><strong>Optional keyword arguments</strong></p><ul><li><code>ntransforms = Val(1)</code>: the number of simultaneous transforms to perform. This is useful if one wants to transform multiple scalar quantities at the same non-uniform points.</li></ul><p><strong>NUFFT parameters</strong></p><ul><li><p><code>m = HalfSupport(8)</code>: the half-support of the convolution kernels. Large values increase accuracy at the cost of performance.</p></li><li><p><code>σ = 2.0</code>: NUFFT oversampling factor. Typical values are 2.0 (more accurate) and 1.25 (faster), but other values such as 1.5 should also work.</p></li><li><p><code>kernel::AbstractKernel = BackwardsKaiserBesselKernel()</code>: convolution kernel used for NUFFTs.</p></li></ul><p><strong>Performance parameters</strong></p><ul><li><p><code>block_size = 4096</code>: the linear block size (in number of elements) when using block partitioning. This can be tuned for maximal performance. Using block partitioning is required for running with multiple threads. Blocking can be completely disabled by passing <code>block_size = nothing</code> (but this is generally slower, even when running on a single thread).</p></li><li><p><code>sort_points = False()</code>: whether to internally permute the order of the non-uniform points. This can be enabled by passing <code>sort_points = True()</code>. In this case, more time will be spent in <a href="#NonuniformFFTs.set_points!"><code>set_points!</code></a> and less time on the actual transforms. This can improve performance if executing multiple transforms on the same non-uniform points. Note that, even when enabled, this does not modify the <code>points</code> argument passed to <code>set_points!</code>.</p></li></ul><p><strong>Other parameters</strong></p><ul><li><p><code>fftw_flags = FFTW.MEASURE</code>: parameters passed to the FFTW planner.</p></li><li><p><code>fftshift = false</code>: determines the order of wavenumbers in uniform space. If <code>false</code> (default), the same order used by FFTW is used, with positive wavenumbers first (<code>[0, 1, 2, …, N÷2-1]</code> for even-size transforms) and negative ones afterwards ([-N÷2, …, -1]). Otherwise, wavenumbers are expected to be in increasing order ([-N÷2, -kmax, …, -1, 0, 1, …, N÷2-1]), which is compatible with the output in NFFT.jl and corresponds to applying the <code>AbstractFFTs.fftshift</code> function to the data. This option also corresponds to the <code>modeord</code> parameter in FINUFFT. This only affects complex-to-complex transforms.</p></li><li><p><code>timer = TimerOutput()</code>: allows to specify a <code>TimerOutput</code> (from the <a href="https://github.com/KristofferC/TimerOutputs.jl">TimerOutputs.jl</a> package) where timing information will be written to. By default the plan creates its own timer. One can visualise the time spent on different parts of the NUFFT computation using <code>p.timer</code>.</p></li></ul><p><strong>FFT size and performance</strong></p><p>For performance reasons, when doing FFTs one usually wants the size of the input along each dimension to be a power of 2 (ideally), or the product of powers of small prime numbers (2, 3, 5, …). The problem is that, with the NUFFT, one does not directly control the FFT size due to the oversampling factor <span>$σ$</span>, which may be any real number <span>$σ &gt; 1$</span>. That is, for an input of size <span>$N$</span>, FFTs are performed on an oversampled grid of size <span>$Ñ ≈ σN$</span>. Note that <span>$σN$</span> is generally not an integer, hence the <span>$≈$</span>.</p><p>The aim of this section is to clarify how <span>$Ñ$</span> is actually chosen, so that one can predict its value for given inputs <span>$N$</span> and <span>$σ$</span>. This may be better understood in actual code:</p><pre><code class="language-julia hljs">Ñ = nextprod((2, 3, 5), floor(Int, σ * N))</code></pre><p>Basically, we truncate <span>$σN$</span> to an integer, and then we choose <span>$Ñ$</span> as the next integer that can be written as the product of powers of 2, 3 and 5 (see <a href="https://docs.julialang.org/en/v1/base/math/#Base.nextprod"><code>nextprod</code></a>). Most often, the result will be greater than or equal to <span>$σN$</span>.</p><p><strong>Using real non-uniform data</strong></p><p>In some applications, the non-uniform data to be transformed is purely real. In this case, one may pass <code>Float64</code> or <code>Float32</code> as the first argument. This may be faster than converting data to complex types, in particular because the real-to-complex FFTs from FFTW will be used to compute the transforms. Note that, in this case, the dimensions of the uniform data arrays is not exactly <code>dims</code>, since the size of the first dimension is divided roughly by 2 (taking advantage of Hermitian symmetry). For convenience, one can call <a href="#Base.size-Tuple{PlanNUFFT}"><code>size(::PlanNUFFT)</code></a> on the constructed plan to know in advance the dimensions of the uniform data arrays.</p><hr/><pre><code class="nohighlight hljs">PlanNUFFT(xp::AbstractMatrix{T}, dims::Dims{D}; kwargs...)</code></pre><p>Create a <a href="#NonuniformFFTs.PlanNUFFT"><code>PlanNUFFT</code></a> which is compatible with the <a href="https://juliamath.github.io/NFFT.jl/stable/abstract/">AbstractNFFTs.jl</a> interface.</p><p>This constructor requires passing the non-uniform locations <code>xp</code> as the first argument. These should be given as a matrix of dimensions <code>(D, Np)</code>, where <code>D</code> is the spatial dimension and <code>Np</code> the number of non-uniform points.</p><p>The second argument is simply the size <code>(N₁, N₂, …)</code> of the uniform data arrays.</p><p>This variant creates a plan which assumes complex-valued non-uniform data. For real-valued data, the other constructor should be used instead.</p><p><strong>Compatibility with NFFT.jl</strong></p><p>Most of the <a href="https://juliamath.github.io/NFFT.jl/stable/overview/#Parameters">parameters</a> supported by the NFFT.jl package are also supported by this constructor. The currently supported parameters are <code>reltol</code>, <code>m</code>, <code>σ</code>, <code>window</code>, <code>blocking</code>, <code>sortNodes</code> and <code>fftflags</code>.</p><p>Moreover, unlike the first variant, this constructor sets <code>fftshift = true</code> by default (but can be overridden) so that the uniform data ordering is the same as in NFFT.jl.</p><div class="admonition is-warning"><header class="admonition-header">Type instability</header><div class="admonition-body"><p>Explicitly passing some of these parameters may result in type-unstable code, since the exact type of the returned plan cannot be inferred. This is because, in NonuniformFFTs.jl, parameters such as the kernel size (<code>m</code>) or the convolution window (<code>window</code>) are included in the plan type (they are compile-time constants).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/plan.jl#L57-L180">source</a></section></article><h2 id="Setting-non-uniform-points"><a class="docs-heading-anchor" href="#Setting-non-uniform-points">Setting non-uniform points</a><a id="Setting-non-uniform-points-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-non-uniform-points" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.set_points!" href="#NonuniformFFTs.set_points!"><code>NonuniformFFTs.set_points!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_points!(p::PlanNUFFT, points)</code></pre><p>Set non-uniform points before executing a NUFFT.</p><p>In one dimension, <code>points</code> is simply a vector of real values (the non-uniform locations).</p><p>In multiple dimensions, <code>points</code> may be passed as:</p><ul><li>a tuple of vectors <code>(xs::AbstractVector, ys::AbstractVector, …)</code>;</li><li>a vector <code>[x⃗₁, x⃗₂, x⃗₃, x⃗₄, …]</code> of tuples or static vectors (typically <code>SVector</code>s from the StaticArrays.jl package);</li><li>a matrix of size <code>(d, Np)</code> where <code>d</code> is the spatial dimension and <code>Np</code> the number of non-uniform points.</li></ul><p>The points are allowed to be outside of the periodic cell <span>$[0, 2π)^d$</span>, in which case they will be &quot;folded&quot; to that domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/set_points.jl#L1-L17">source</a></section></article><h2 id="Executing-plans"><a class="docs-heading-anchor" href="#Executing-plans">Executing plans</a><a id="Executing-plans-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-plans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.exec_type1!" href="#NonuniformFFTs.exec_type1!"><code>NonuniformFFTs.exec_type1!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exec_type1!(ûs::AbstractArray{&lt;:Complex}, p::PlanNUFFT, vp::AbstractVector{&lt;:Number})
exec_type1!(ûs::NTuple{N, AbstractArray{&lt;:Complex}}, p::PlanNUFFT, vp::NTuple{N, AbstractVector{&lt;:Number}})</code></pre><p>Perform type-1 NUFFT (from non-uniform points to uniform grid).</p><p>Here <code>vp</code> contains the input values at non-uniform points. The result of the transform is written into <code>ûs</code>.</p><p>One first needs to set the non-uniform points using <a href="#NonuniformFFTs.set_points!"><code>set_points!</code></a>.</p><p>To perform multiple transforms at once, both <code>vp</code> and <code>ûs</code> should be a tuple of arrays (second variant above). Note that this requires a plan initialised with <code>ntransforms = Val(N)</code> (see <a href="#NonuniformFFTs.PlanNUFFT"><code>PlanNUFFT</code></a>).</p><p>See also <a href="#NonuniformFFTs.exec_type2!"><code>exec_type2!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/NonuniformFFTs.jl#L127-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.exec_type2!" href="#NonuniformFFTs.exec_type2!"><code>NonuniformFFTs.exec_type2!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exec_type2!(vp::AbstractVector{&lt;:Number}, p::PlanNUFFT, ûs::AbstractArray{&lt;:Complex})
exec_type2!(vp::NTuple{N, AbstractVector{&lt;:Number}}, p::PlanNUFFT, ûs::NTuple{N, AbstractArray{&lt;:Complex}})</code></pre><p>Perform type-2 NUFFT (from uniform grid to non-uniform points).</p><p>Here <code>ûs</code> contains the input coefficients in the uniform grid. The result of the transform at non-uniform points is written into <code>vp</code>.</p><p>One first needs to set the non-uniform points using <a href="#NonuniformFFTs.set_points!"><code>set_points!</code></a>.</p><p>To perform multiple transforms at once, both <code>vp</code> and <code>ûs</code> should be a tuple of arrays (second variant above). Note that this requires a plan initialised with <code>ntransforms = Val(N)</code> (see <a href="#NonuniformFFTs.PlanNUFFT"><code>PlanNUFFT</code></a>).</p><p>See also <a href="#NonuniformFFTs.exec_type1!"><code>exec_type1!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/NonuniformFFTs.jl#L196-L211">source</a></section></article><h2 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{PlanNUFFT}" href="#Base.size-Tuple{PlanNUFFT}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(p::PlanNUFFT) -&gt; (N₁, N₂, ...)</code></pre><p>Return the dimensions of arrays containing uniform values.</p><p>This corresponds to the number of Fourier modes in each direction (in the non-oversampled grid).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/plan.jl#L214-L220">source</a></section></article><h2 id="Available-spreading-kernels"><a class="docs-heading-anchor" href="#Available-spreading-kernels">Available spreading kernels</a><a id="Available-spreading-kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Available-spreading-kernels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.Kernels.KaiserBesselKernel" href="#NonuniformFFTs.Kernels.KaiserBesselKernel"><code>NonuniformFFTs.Kernels.KaiserBesselKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KaiserBesselKernel &lt;: AbstractKernel
KaiserBesselKernel([β])</code></pre><p>Represents a <a href="https://en.wikipedia.org/wiki/Kaiser_window#Definition">Kaiser–Bessel</a> spreading kernel.</p><p><strong>Definition</strong></p><p class="math-container">\[ϕ(x) = I₀ \left(β \sqrt{1 - x²} \right)
\quad \text{ for } |x| ≤ 1\]</p><p>where <span>$I₀$</span> is the zeroth-order <a href="https://en.wikipedia.org/wiki/Modified_Bessel_function#Modified_Bessel_functions:_I%CE%B1,_K%CE%B1">modified Bessel function</a> of the first kind and <span>$β$</span> is a shape factor.</p><p><strong>Fourier transform</strong></p><p class="math-container">\[ϕ̂(k) = 2 \frac{\sinh\left( \sqrt{β² - k²} \right)}{\sqrt{β² - k²}}\]</p><p><strong>Parameter selection</strong></p><p>By default, the shape parameter is chosen to be [1]</p><p class="math-container">\[β = γ M π \left( 2 - \frac{1}{σ} \right)\]</p><p>where <span>$M$</span> is the kernel half-width and <span>$σ$</span> the oversampling factor. Moreover, <span>$γ = 0.980$</span> is an empirical &quot;safety factor&quot;, similarly to the one used by FINUFFT [2], which slightly improves accuracy.</p><p>This default value can be overriden by explicitly passing a <span>$β$</span> value.</p><p><strong>Implementation details</strong></p><p>Since the evaluation of Bessel functions can be costly, this kernel is efficiently evaluated via an accurate piecewise polynomial approximation. We use the same method originally proposed for FINUFFT [2] and later discussed by Shamshirgar et al. [3].</p><p>[1] Potts &amp; Steidl, SIAM J. Sci. Comput. <strong>24</strong>, 2013 (2003) <br/>[2] Barnett, Magland &amp; af Klinteberg, SIAM J. Sci. Comput. <strong>41</strong>, C479 (2019) <br/>[3] Shamshirgar, Bagge &amp; Tornberg, J. Chem. Phys. <strong>154</strong>, 164109 (2021)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/Kernels/kaiser_bessel.jl#L9-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.Kernels.BackwardsKaiserBesselKernel" href="#NonuniformFFTs.Kernels.BackwardsKaiserBesselKernel"><code>NonuniformFFTs.Kernels.BackwardsKaiserBesselKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BackwardsKaiserBesselKernel &lt;: AbstractKernel
BackwardsKaiserBesselKernel([β])</code></pre><p>Represents a backwards <a href="https://en.wikipedia.org/wiki/Kaiser_window#Definition">Kaiser–Bessel</a> (KB) spreading kernel.</p><p>This kernel basically results from swapping the <a href="#NonuniformFFTs.Kernels.KaiserBesselKernel"><code>KaiserBesselKernel</code></a> spreading function and its Fourier transform. It has very similar properties to the Kaiser–Bessel kernel.</p><p><strong>Definition</strong></p><p class="math-container">\[ϕ(x) = \frac{\sinh \left(β \sqrt{1 - x²} \right)}{π \sqrt{1 - x²}}
\quad \text{ for } |x| ≤ 1\]</p><p>where <span>$β$</span> is a shape factor.</p><p><strong>Fourier transform</strong></p><p class="math-container">\[ϕ̂(k) = I₀ \left( \sqrt{β² - k²} \right)\]</p><p>where <span>$I₀$</span> is the zeroth-order <a href="https://en.wikipedia.org/wiki/Modified_Bessel_function#Modified_Bessel_functions:_I%CE%B1,_K%CE%B1">modified Bessel function</a> of the first kind.</p><p><strong>Parameter selection</strong></p><p>By default, the shape parameter is chosen to be [1]</p><p class="math-container">\[β = γ M π \left( 2 - \frac{1}{σ} \right)\]</p><p>where <span>$M$</span> is the kernel half-width and <span>$σ$</span> the oversampling factor. Moreover, <span>$γ = 0.995$</span> is an empirical &quot;safety factor&quot;, similarly to the one used by FINUFFT [2], which slightly improves accuracy.</p><p>This default value can be overriden by explicitly passing a <span>$β$</span> value.</p><p><strong>Implementation details</strong></p><p>Since the evaluation of the hyperbolic sine functions can be costly, this kernel is efficiently evaluated via an accurate piecewise polynomial approximation. We use the same method originally proposed for FINUFFT [2] and later discussed by Shamshirgar et al. [3].</p><p>[1] Potts &amp; Steidl, SIAM J. Sci. Comput. <strong>24</strong>, 2013 (2003) <br/>[2] Barnett, Magland &amp; af Klinteberg, SIAM J. Sci. Comput. <strong>41</strong>, C479 (2019) <br/>[3] Shamshirgar, Bagge &amp; Tornberg, J. Chem. Phys. <strong>154</strong>, 164109 (2021)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/Kernels/kaiser_bessel_backwards.jl#L7-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.Kernels.GaussianKernel" href="#NonuniformFFTs.Kernels.GaussianKernel"><code>NonuniformFFTs.Kernels.GaussianKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianKernel &lt;: AbstractKernel
GaussianKernel([ℓ/Δx])</code></pre><p>Represents a truncated Gaussian spreading kernel.</p><p><strong>Definition</strong></p><p class="math-container">\[ϕ(x) = e^{-x² / 2ℓ²}\]</p><p>where <span>$ℓ$</span> is the characteristic width of the kernel.</p><p><strong>Fourier transform</strong></p><p class="math-container">\[ϕ̂(k) = \sqrt{2πℓ²} e^{-ℓ² k² / 2}\]</p><p><strong>Parameter selection</strong></p><p>By default, given a kernel half-width <span>$M$</span>, an oversampling factor <span>$σ$</span> and the oversampling grid spacing <span>$Δx$</span>, the characteristic width <span>$ℓ$</span> is chosen as [1]</p><p class="math-container">\[ℓ² = Δx² \frac{σ}{2σ - 1} \frac{M}{π}\]</p><p>This default value can be overriden by explicitly passing a value of the wanted normalised width <span>$ℓ/Δx$</span>.</p><p><strong>Implementation details</strong></p><p>In the implementation, this kernel is efficiently evaluated using the fast Gaussian gridding method proposed by Greengard &amp; Lee [2].</p><p>[1] Potts &amp; Steidl, SIAM J. Sci. Comput. <strong>24</strong>, 2013 (2003) <br/>[2] Greengard &amp; Lee, SIAM Rev. <strong>46</strong>, 443 (2004)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/Kernels/gaussian.jl#L6-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NonuniformFFTs.Kernels.BSplineKernel" href="#NonuniformFFTs.Kernels.BSplineKernel"><code>NonuniformFFTs.Kernels.BSplineKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSplineKernel &lt;: AbstractKernel
BSplineKernel()</code></pre><p>Represents a B-spline spreading kernel.</p><p>The order <span>$n$</span> of the B-spline is directly related to the kernel half-width <span>$M$</span> by <span>$n = 2M$</span> (the polynomial degree is <span>$n - 1$</span>).</p><p><strong>Definition</strong></p><p>A B-spline of order <span>$n$</span> may be defined via its Fourier transform:</p><p class="math-container">\[ϕ̂(k) = Δx \operatorname{sinc}^n \left( \frac{k Δx}{2} \right)\]</p><p>where <span>$Δx$</span> is the spacing of the oversampled grid and <span>$\operatorname{sinc}$</span> is the <a href="https://en.wikipedia.org/wiki/Sinc_function">unnormalised sinc function</a>.</p><p><strong>Implementation details</strong></p><p>In the implementation, this kernel is evaluated using <a href="https://en.wikipedia.org/wiki/De_Boor%27s_algorithm">de Boor&#39;s algorithm</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/NonuniformFFTs.jl/blob/77d4b339da2812feec645214af72267a56c49fd0/src/Kernels/bspline.jl#L6-L30">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#NonuniformFFTs.Kernels.BSplineKernel"><code>NonuniformFFTs.Kernels.BSplineKernel</code></a></li><li><a href="#NonuniformFFTs.Kernels.BackwardsKaiserBesselKernel"><code>NonuniformFFTs.Kernels.BackwardsKaiserBesselKernel</code></a></li><li><a href="#NonuniformFFTs.Kernels.GaussianKernel"><code>NonuniformFFTs.Kernels.GaussianKernel</code></a></li><li><a href="#NonuniformFFTs.Kernels.KaiserBesselKernel"><code>NonuniformFFTs.Kernels.KaiserBesselKernel</code></a></li><li><a href="#NonuniformFFTs.PlanNUFFT"><code>NonuniformFFTs.PlanNUFFT</code></a></li><li><a href="#Base.size-Tuple{PlanNUFFT}"><code>Base.size</code></a></li><li><a href="#NonuniformFFTs.exec_type1!"><code>NonuniformFFTs.exec_type1!</code></a></li><li><a href="#NonuniformFFTs.exec_type2!"><code>NonuniformFFTs.exec_type2!</code></a></li><li><a href="#NonuniformFFTs.set_points!"><code>NonuniformFFTs.set_points!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../accuracy/">« Accuracy</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 13 September 2024 11:42">Friday 13 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
