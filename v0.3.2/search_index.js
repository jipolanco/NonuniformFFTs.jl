var documenterSearchIndex = {"docs":
[{"location":"#NonuniformFFTs.jl","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"","category":"section"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CurrentModule = NonuniformFFTs","category":"page"},{"location":"API/#Creating-plans","page":"API","title":"Creating plans","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"PlanNUFFT","category":"page"},{"location":"API/#NonuniformFFTs.PlanNUFFT","page":"API","title":"NonuniformFFTs.PlanNUFFT","text":"PlanNUFFT([T = ComplexF64], dims::Dims; ntransforms = Val(1), kwargs...)\n\nConstruct a plan for performing non-uniform FFTs (NUFFTs).\n\nThe created plan contains all data needed to perform NUFFTs for non-uniform data of type T (ComplexF64 by default) and uniform data with dimensions dims.\n\nOptional keyword arguments\n\nntransforms = Val(1): the number of simultaneous transforms to perform. This is useful if one wants to transform multiple scalar quantities at the same non-uniform points.\n\nNUFFT parameters\n\nm = HalfSupport(8): the half-support of the convolution kernels. Large values increase accuracy at the cost of performance.\nσ = 2.0: NUFFT oversampling factor. Typical values are 2.0 (more accurate) and 1.25 (faster), but other values such as 1.5 should also work.\nkernel::AbstractKernel = BackwardsKaiserBesselKernel(): convolution kernel used for NUFFTs.\n\nPerformance parameters\n\nblock_size = 4096: the linear block size (in number of elements) when using block partitioning. This can be tuned for maximal performance. Using block partitioning is required for running with multiple threads. Blocking can be completely disabled by passing block_size = nothing (but this is generally slower, even when running on a single thread).\nsort_points = False(): whether to internally permute the order of the non-uniform points. This can be enabled by passing sort_points = True(). In this case, more time will be spent in set_points! and less time on the actual transforms. This can improve performance if executing multiple transforms on the same non-uniform points. Note that, even when enabled, this does not modify the points argument passed to set_points!.\n\nOther parameters\n\nfftw_flags = FFTW.MEASURE: parameters passed to the FFTW planner.\ntimer = TimerOutput(): allows to specify a TimerOutput (from the TimerOutputs.jl package) where timing information will be written to. By default the plan creates its own timer. One can visualise the time spent on different parts of the NUFFT computation using p.timer.\n\nUsing real non-uniform data\n\nIn some applications, the non-uniform data to be transformed is purely real. In this case, one may pass Float64 or Float32 as the first argument. This may be faster than converting data to complex types, in particular because the real-to-complex FFTs from FFTW will be used to compute the transforms. Note that, in this case, the dimensions of the uniform data arrays is not exactly dims, since the size of the first dimension is divided roughly by 2 (taking advantage of Hermitian symmetry). For convenience, one can call size(::PlanNUFFT) on the constructed plan to know in advance the dimensions of the uniform data arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#Setting-non-uniform-points","page":"API","title":"Setting non-uniform points","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"set_points!","category":"page"},{"location":"API/#NonuniformFFTs.set_points!","page":"API","title":"NonuniformFFTs.set_points!","text":"set_points!(p::PlanNUFFT, points)\n\nSet non-uniform points before executing a NUFFT.\n\nIn one dimension, points is simply a vector of real values (the non-uniform locations).\n\nIn multiple dimensions, points may be passed as:\n\na tuple of vectors (xs::AbstractVector, ys::AbstractVector, …),\na vector [x⃗₁, x⃗₂, x⃗₃, x⃗₄, …] of tuples or static vectors (typically SVectors from the StaticArrays.jl package).\n\nThe points are allowed to be outside of the periodic cell 0 2π)^d, in which case they will be \"folded\" to that domain.\n\n\n\n\n\n","category":"function"},{"location":"API/#Executing-plans","page":"API","title":"Executing plans","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"exec_type1!\nexec_type2!","category":"page"},{"location":"API/#NonuniformFFTs.exec_type1!","page":"API","title":"NonuniformFFTs.exec_type1!","text":"exec_type1!(ûs::AbstractArray{<:Complex}, p::PlanNUFFT, vp::AbstractVector{<:Number})\nexec_type1!(ûs::NTuple{N, AbstractArray{<:Complex}}, p::PlanNUFFT, vp::NTuple{N, AbstractVector{<:Number}})\n\nPerform type-1 NUFFT (from non-uniform points to uniform grid).\n\nHere vp contains the input values at non-uniform points. The result of the transform is written into ûs.\n\nOne first needs to set the non-uniform points using set_points!.\n\nTo perform multiple transforms at once, both vp and ûs should be a tuple of arrays (second variant above). Note that this requires a plan initialised with ntransforms = Val(N) (see PlanNUFFT).\n\nSee also exec_type2!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NonuniformFFTs.exec_type2!","page":"API","title":"NonuniformFFTs.exec_type2!","text":"exec_type2!(vp::AbstractVector{<:Number}, p::PlanNUFFT, ûs::AbstractArray{<:Complex})\nexec_type2!(vp::NTuple{N, AbstractVector{<:Number}}, p::PlanNUFFT, ûs::NTuple{N, AbstractArray{<:Complex}})\n\nPerform type-2 NUFFT (from uniform grid to non-uniform points).\n\nHere ûs contains the input coefficients in the uniform grid. The result of the transform at non-uniform points is written into vp.\n\nOne first needs to set the non-uniform points using set_points!.\n\nTo perform multiple transforms at once, both vp and ûs should be a tuple of arrays (second variant above). Note that this requires a plan initialised with ntransforms = Val(N) (see PlanNUFFT).\n\nSee also exec_type1!.\n\n\n\n\n\n","category":"function"},{"location":"API/#Other-functions","page":"API","title":"Other functions","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"size(::PlanNUFFT)","category":"page"},{"location":"API/#Base.size-Tuple{PlanNUFFT}","page":"API","title":"Base.size","text":"size(p::PlanNUFFT) -> (N₁, N₂, ...)\n\nReturn the dimensions of arrays containing uniform values.\n\nThis corresponds to the number of Fourier modes in each direction (in the non-oversampled grid).\n\n\n\n\n\n","category":"method"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]","category":"page"}]
}
