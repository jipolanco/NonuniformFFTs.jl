var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Pages = [\"benchmarks.md\"]\nDepth = 2:3","category":"page"},{"location":"benchmarks/#Introduction","page":"Benchmarks","title":"Introduction","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks consist in type-1 and type-2 NUFFTs on a uniform 3D grid of fixed dimensions M^3 = 256^3 (excluding oversampling). We vary the number of non-uniform points N, so that the point density ρ = N  M^3 takes values between 10^-4 (very few points) and 10^1 (very dense). Points are randomly located in 0 2π)^3 using a uniform distribution. The relative tolerance is fixed to 10^-6. In NonuniformFFTs.jl, this can be achieved with the parameters σ = 1.5 (oversampling factor) and m = HalfSupport(4) (see Accuracy). All tests are run in double precision (Float64 or ComplexF64 non-uniform data).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The tests were run on a cluster with an AMD EPYC 7302 CPU (32 threads) and an NVIDIA A100 GPU.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks compare NonuniformFFTs.jl v0.6.7 (26/11/2024) and FINUFFT v2.3.1 (see FINUFFT set-up for details).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Each reported time includes (1) the time spent processing non-uniform points (set_points! / (cu)finufft_setpts!) and (2) the time spent on the actual transform (exec_type{1,2}! / (cu)finufft_exec!).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The script used for benchmarking can be found in benchmark/comparisons/run_benchmarks.jl.","category":"page"},{"location":"benchmarks/#benchmarks-complex","page":"Benchmarks","title":"Complex non-uniform data","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p>\nLibraries like FINUFFT or NFFT.jl only support complex non-uniform data.\nTherefore, these tests provide a direct comparison of the performance of different libraries.\nOn the CPU (<b>crosses</b>), the performance of the multi-threaded NonuniformFFTs.jl (<span class=NonuniformFFTs>blue</span>) and\nFINUFFT (<span class=FINUFFT>orange</span>) implementations is quite comparable over a wide range of problem sizes.\n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"On the GPU, we test two different implementations which are heavily inspired by the CuFINUFFT paper (Shih et al., 2021). The default one (filled circles) corresponds to setting gpu_method = :global_memory in PlanNUFFT. This method is slightly faster than CuFINUFFT at low point densities, but slightly slower at large ones.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In fact, at large densities it actually faster to use the non-default gpu_method = :shared_memory option (open circles, labelled \"SM\" in the figures). The :shared_memory method performs some operations on GPU shared memory (also called local data share), which is small but much faster than the GPU's global memory. During spreading (type-1 transforms), this approach allows to reduce the number of atomic operations performed in global memory. Our implementation is inspired by the CuFINUFFT one (Shih et al., 2021) with a few differences. In particular, we completely avoid atomic operations on shared memory, which seems to speed up things quite a bit and might explain the important gains with respect to the CuFINUFFT implementation.[1] We also provide a shared-memory implementation of type-2 transforms (interpolation). As seen below, this can enable some minor gains at large point densities.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: The CuFINUFFT shared-memory implementation might perform better (relative to the global-memory method) for two-dimensional or low-accuracy problems.","category":"page"},{"location":"benchmarks/#Type-1-transforms","page":"Benchmarks","title":"Type-1 transforms","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<img width=\"100%\" src=\"../img/benchmark_ComplexF64_type1.svg\">","category":"page"},{"location":"benchmarks/#benchmarks-complex-type2","page":"Benchmarks","title":"Type-2 transforms","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<img width=\"100%\" src=\"../img/benchmark_ComplexF64_type2.svg\">","category":"page"},{"location":"benchmarks/#benchmarks-real","page":"Benchmarks","title":"Real non-uniform data","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These tests are of interest for applications where non-uniform data is real-valued (imaginary part is zero). In NonuniformFFTs.jl, this enables the use of real-to-complex (type-1) and complex-to-real (type-2) FFTs and also allows to halve the amount of data processed during the spreading (type-1) and interpolation (type-2) procedures. The benchmarks showcase the important gains which can be obtained by using real-data transforms, which are not available in other libraries like FINUFFT or NFFT.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In the plots below, the (Cu)FINUFFT curves are exactly the same as in the complex-data benchmarks.","category":"page"},{"location":"benchmarks/#Type-1-transforms-2","page":"Benchmarks","title":"Type-1 transforms","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<img width=\"100%\" src=\"../img/benchmark_Float64_type1.svg\">","category":"page"},{"location":"benchmarks/#Type-2-transforms","page":"Benchmarks","title":"Type-2 transforms","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<img width=\"100%\" src=\"../img/benchmark_Float64_type2.svg\">","category":"page"},{"location":"benchmarks/#FINUFFT-set-up","page":"Benchmarks","title":"FINUFFT set-up","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We used FINUFFT via its Julia wrapper FINUFFT.jl v3.3.0. For performance reasons, the (Cu)FINUFFT libraries were compiled locally and the FINUFFT.jl sources were modified accordingly as described here. FINUFFT was compiled with GCC 10.2.0 using CMake with its default flags in Release mode, which include -fPIC -funroll-loops -O3 -march=native. Moreover, we set CMAKE_CUDA_ARCHITECTURES=80 (for an NVIDIA A100) and used the nvcc compiler included in CUDA 12.3.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All FINUFFT benchmarks were run with relative tolerance 1e-6. Moreover, the following options were used:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"modeord = 1 (use FFTW ordering, for consistency with NonuniformFFTs)\nspread_sort = 1 (enable point sorting in CPU plans)\nspread_kerevalmeth = 1 (use the recommended piecewise polynomial evaluation)\nfftw = FFTW.ESTIMATE (CPU plans)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"and for GPU plans:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"gpu_sort = 1 (enable point sorting)\ngpu_kerevalmeth = 1 (use piecewise polynomial evaluation)\ngpu_method = 1 (global memory method, \"non-uniform points driven\")","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We also tried gpu_method = 2 (open symbols, labelled SM) which seems to be considerably slower in nearly all cases (in three dimensions, at the requested tolerance).","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Basic-usage","page":"Examples","title":"Basic usage","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first two examples illustrate how to perform type-1 and type-2 NUFFTs in one dimension. In these examples the non-uniform data is real-valued, but it could be easily made complex by replacing Float64 with ComplexF64.","category":"page"},{"location":"examples/#Type-1-(or-*adjoint*)-NUFFT-in-one-dimension","page":"Examples","title":"Type-1 (or adjoint) NUFFT in one dimension","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using NonuniformFFTs\nusing AbstractFFTs: rfftfreq  # can be used to obtain the associated Fourier wavenumbers\n\nN = 256   # number of Fourier modes\nNp = 100  # number of non-uniform points\nks = rfftfreq(N, N)  # Fourier wavenumbers\n\n# Generate some non-uniform random data\nT = Float64             # non-uniform data is real (can also be complex)\nxp = rand(T, Np) .* 2π  # non-uniform points in [0, 2π]\nvp = randn(T, Np)       # random values at points\n\n# Create plan for data of type T\nplan_nufft = PlanNUFFT(T, N; m = HalfSupport(4))  # larger support increases accuracy\n\n# Set non-uniform points\nset_points!(plan_nufft, xp)\n\n# Perform type-1 NUFFT on preallocated output\nûs = Array{Complex{T}}(undef, size(plan_nufft))\nexec_type1!(ûs, plan_nufft, vp)\nnothing  # hide","category":"page"},{"location":"examples/#Type-2-(or-*direct*)-NUFFT-in-one-dimension","page":"Examples","title":"Type-2 (or direct) NUFFT in one dimension","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using NonuniformFFTs\n\nN = 256   # number of Fourier modes\nNp = 100  # number of non-uniform points\n\n# Generate some uniform random data\nT = Float64                        # non-uniform data is real (can also be complex)\nxp = rand(T, Np) .* 2π             # non-uniform points in [0, 2π]\nûs = randn(Complex{T}, N ÷ 2 + 1)  # random values at points (we need to store roughly half the Fourier modes for complex-to-real transform)\n\n# Create plan for data of type T\nplan_nufft = PlanNUFFT(T, N; m = HalfSupport(4))\n\n# Set non-uniform points\nset_points!(plan_nufft, xp)\n\n# Perform type-2 NUFFT on preallocated output\nvp = Array{T}(undef, Np)\nexec_type2!(vp, plan_nufft, ûs)\nnothing  # hide","category":"page"},{"location":"examples/#Multidimensional-transforms","page":"Examples","title":"Multidimensional transforms","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To perform a d-dimensional transform, one simply needs to pass a tuple of dimensions (Nx, Ny, …) to PlanNUFFT. Moreover, the vector of d-dimensional positions should be specified as a tuple of vectors (xs, ys, …):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using NonuniformFFTs\n\nNs = (256, 256)  # number of Fourier modes in each direction\nNp = 1000        # number of non-uniform points\n\n# Generate some non-uniform random data\nT = Float64                # non-uniform data is real (can also be complex)\nd = length(Ns)             # number of dimensions (d = 2 here)\nxp = rand(T, Np) .* T(2π)  # non-uniform points in [0, 2π] (dimension 1)\nyp = rand(T, Np) .* T(2π)  # non-uniform points in [0, 2π] (dimension 2)\nvp = randn(T, Np)          # random values at points\n\n# Create plan for data of type T\nplan_nufft = PlanNUFFT(T, Ns; m = HalfSupport(4))\n\n# Set non-uniform points\npoints = (xp, yp)\nset_points!(plan_nufft, points)\n\n# Perform type-1 NUFFT on preallocated output\nûs = Array{Complex{T}}(undef, size(plan_nufft))\nexec_type1!(ûs, plan_nufft, vp)\n\n# Perform type-2 NUFFT on preallocated output\nwp = similar(vp)\nexec_type2!(wp, plan_nufft, ûs)\nnothing  # hide","category":"page"},{"location":"examples/#Multiple-transforms-on-the-same-non-uniform-points","page":"Examples","title":"Multiple transforms on the same non-uniform points","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"One may want to perform multiple transforms with the same non-uniform points. For example, this can be useful for dealing with vector quantities (as opposed to scalar ones). To do this, one should pass ntransforms = Val(Nt) where Nt is the number of transforms to perform. Moreover, the input and output data should be tuples of arrays of length Nt, as shown below.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using NonuniformFFTs\n\nN = 256   # number of Fourier modes\nNp = 100  # number of non-uniform points\nntrans = Val(3)  # number of simultaneous transforms\n\n# Generate some non-uniform random data\nT = Float64             # non-uniform data is real (can also be complex)\nxp = rand(T, Np) .* 2π  # non-uniform points in [0, 2π]\nvp = ntuple(_ -> randn(T, Np), ntrans)  # random values at points (this is a tuple of 3 arrays)\n\n# Create plan for data of type T\nplan_nufft = PlanNUFFT(T, N; ntransforms = ntrans)\n\n# Set non-uniform points\nset_points!(plan_nufft, xp)\n\n# Perform type-1 NUFFT on preallocated output (one array per transformed quantity)\nûs = ntuple(_ -> Array{Complex{T}}(undef, size(plan_nufft)), ntrans)  # this is a tuple of 3 arrays\nexec_type1!(ûs, plan_nufft, vp)\n\n# Perform type-2 NUFFT on preallocated output (one vector per transformed quantity)\nwp = map(similar, vp)  # this is a tuple of 3 vectors\nexec_type2!(wp, plan_nufft, ûs)\nnothing  # hide","category":"page"},{"location":"examples/#GPU-usage","page":"Examples","title":"GPU usage","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Below is a GPU version of the multidimensional transform example above. The only differences are:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"we import CUDA.jl\nwe import Adapt.jl (optional but convenient)\nwe pass backend = CUDABackend() to PlanNUFFT (CUDABackend is a KernelAbstractions backend and is exported by CUDA.jl). The default is backend = CPU().\nwe copy input arrays to the GPU before calling any NUFFT-related functions (set_points!, exec_type1!, exec_type2!)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example is for an Nvidia GPU (using CUDA.jl), but should also work with e.g. AMDGPU.jl on an AMD GPU by simply choosing backend = ROCBackend().","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using NonuniformFFTs\nusing CUDA\nusing Adapt: adapt  # optional (see below)\n\nbackend = CUDABackend()  # other options are CPU() or ROCBackend()\n\nNs = (256, 256)  # number of Fourier modes in each direction\nNp = 1000        # number of non-uniform points\n\n# Generate some non-uniform random data\nT = Float64                    # non-uniform data is real (can also be complex)\nd = length(Ns)                 # number of dimensions (d = 2 here)\nxp_cpu = rand(T, Np) .* T(2π)  # non-uniform points in [0, 2π] (dimension 1)\nyp_cpu = rand(T, Np) .* T(2π)  # non-uniform points in [0, 2π] (dimension 2)\nvp_cpu = randn(T, Np)          # random values at points\n\n# Copy data to the GPU (using Adapt is optional but it makes code more generic).\n# Note that all data needs to be on the GPU before setting points or executing transforms.\n# We could have also generated the data directly on the GPU.\npoints_cpu = (xp_cpu, yp_cpu)\npoints = adapt(backend, points_cpu)  # returns a tuple of CuArrays if backend = CUDABackend\nvp = adapt(backend, vp_cpu)\n\n# Create plan for data of type T\nplan_nufft = PlanNUFFT(T, Ns; m = HalfSupport(4), backend)\n\n# Set non-uniform points\nset_points!(plan_nufft, points)\n\n# Perform type-1 NUFFT on preallocated output\nûs = similar(vp, Complex{T}, size(plan_nufft))  # initialises a GPU array for the output\nexec_type1!(ûs, plan_nufft, vp)\n\n# Perform type-2 NUFFT on preallocated output\nexec_type2!(vp, plan_nufft, ûs)","category":"page"},{"location":"examples/#AbstractNFFTs-interface","page":"Examples","title":"AbstractNFFTs.jl interface","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This package also implements the AbstractNFFTs.jl interface as an alternative API for constructing plans and evaluating transforms. This can be useful for comparing with similar packages such as NFFT.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For this, a NFFTPlan constructor (alternative to PlanNUFFT) is provided which supports most of the parameters supported by NFFT.jl. Alternatively, once NonuniformFFTs.jl has been loaded, the plan_nfft function from AbstractNFFTs.jl also generates a NFFTPlan. For compatibility with NFFT.jl, the plan generated via this interface does not follow the same conventions followed by PlanNUFFT plans.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The main differences are:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"points are assumed to be in -12 12) instead of 0 2π);\nthe opposite Fourier sign convention is used (e.g. e^-i k x_j becomes e^+2π i k x_j);\nuniform data is in increasing order, with frequencies k = -N2  -1 0 1  N2-1, as opposed to preserving the order used by FFTW (which starts at k = 0);\npoints locations must be specified as a matrix of dimensions (d, Np).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"warn: Performance of AbstractNFFTs interface\nThe AbstractNFFTs interface can be less efficient than the PlanNUFFT interface described in the previous sections. This is because it requires a few extra operations to switch between point conventions (-12 12)  0 2π)). Moreover, it currently performs extra allocations to switch from the (d, Np) matrix layout of the point locations to the tuple of vectors layout preferred by the PlanNUFFT interface. So, if performance is important, it is recommended to directly use the PlanNUFFT interface.","category":"page"},{"location":"examples/#Example-usage","page":"Examples","title":"Example usage","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using NonuniformFFTs\nusing AbstractNFFTs: AbstractNFFTs, plan_nfft\nusing LinearAlgebra: mul!\n\nNs = (256, 256)  # number of Fourier modes in each direction\nNp = 1000        # number of non-uniform points\n\n# Generate some non-uniform random data\nT = Float64                      # must be a real data type (Float32, Float64)\nd = length(Ns)                   # number of dimensions (d = 2 here)\nxp = rand(T, (d, Np)) .- T(0.5)  # non-uniform points in [-1/2, 1/2)ᵈ; must be given as a (d, Np) matrix\nvp = randn(Complex{T}, Np)       # random values at points (must be complex)\n\n# Create plan for data of type Complex{T}. Note that we pass the points `xp` as\n# a first argument, which calls an AbstractNFFTs-compatible constructor.\np = NonuniformFFTs.NFFTPlan(xp, Ns)\n# p = plan_nfft(xp, Ns)  # this is also possible\n\n# Getting the expected dimensions of input and output data.\nAbstractNFFTs.size_in(p)   # (256, 256)\nAbstractNFFTs.size_out(p)  # (1000,)\n\n# Perform adjoint NFFT, a.k.a. type-1 NUFFT (non-uniform to uniform)\nus = adjoint(p) * vp      # allocates output array `us`\nmul!(us, adjoint(p), vp)  # uses preallocated output array `us`\n\n# Perform forward NFFT, a.k.a. type-2 NUFFT (uniform to non-uniform)\nwp = p * us\nmul!(wp, p, us)\n\n# Setting a different set of non-uniform points\nAbstractNFFTs.nodes!(p, xp)\nnothing  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note: the AbstractNFFTs.jl interface currently only supports complex-valued non-uniform data. For real-to-complex transforms, the standard NonuniformFFTs.jl API demonstrated above (based on PlanNUFFT) should be used instead.","category":"page"},{"location":"accuracy/#accuracy","page":"Accuracy","title":"Accuracy","text":"","category":"section"},{"location":"accuracy/","page":"Accuracy","title":"Accuracy","text":"Here we document the accuracy of the NUFFTs implemented in this package, and how it varies as a function of the kernel half-width M, the oversampling factor σ and the choice of spreading kernel.","category":"page"},{"location":"accuracy/","page":"Accuracy","title":"Accuracy","text":"details: Code for generating this figure\nusing NonuniformFFTs\nusing AbstractFFTs: fftfreq\nusing Random: Random\nusing CairoMakie\n\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 2.0)\n\n# Compute L² distance between two arrays.\nfunction l2_error(us, vs)\n    err = sum(zip(us, vs)) do (u, v)\n        abs2(u - v)\n    end\n    norm = sum(abs2, vs)\n    sqrt(err / norm)\nend\n\nN = 256     # number of Fourier modes\nNp = 2 * N  # number of non-uniform points\n\n# Generate some non-uniform random data\nT = Float64\nrng = Random.Xoshiro(42)\nxp = rand(rng, T, Np) .* 2π      # non-uniform points in [0, 2π]\nvp = randn(rng, Complex{T}, Np)  # complex random values at non-uniform points\n\n# Compute \"exact\" non-uniform transform\nks = fftfreq(N, N)  # Fourier wavenumbers\nûs_exact = zeros(Complex{T}, length(ks))\nfor (i, k) ∈ pairs(ks)\n    ûs_exact[i] = sum(zip(xp, vp)) do (x, v)\n        v * cis(-k * x)\n    end\nend\n\nûs = Array{Complex{T}}(undef, length(ks))  # output of type-1 transforms\nσs = (1.25, 1.5, 2.0)  # oversampling factors to be tested\nMs = 2:12              # kernel half-widths to be tested\nkernels = (            # kernels to be tested\n    BackwardsKaiserBesselKernel(),  # this is the default kernel\n    KaiserBesselKernel(),\n    GaussianKernel(),\n    BSplineKernel(),\n)\n\nerrs = Array{Float64}(undef, length(Ms), length(kernels), length(σs))\n\nfor (k, σ) ∈ pairs(σs), (j, kernel) ∈ pairs(kernels), (i, M) ∈ pairs(Ms)\n    plan = PlanNUFFT(Complex{T}, N; m = HalfSupport(M), σ, kernel)\n    set_points!(plan, xp)\n    exec_type1!(ûs, plan, vp)\n    errs[i, j, k] = l2_error(ûs, ûs_exact)\nend\n\nfig = Figure(size = (450, 1000))\naxs = ntuple(3) do k\n    σ = σs[k]\n    ax = Axis(\n        fig[k, 1];\n        yscale = log10, xlabel = L\"Kernel half width $M$\", ylabel = L\"$L^2$ error\",\n        title = L\"Oversampling factor $σ = %$(σ)$\",\n    )\n    ax.xticks = Ms\n    ax.yticks = LogTicks(-14:2:0)\n    for (j, kernel) ∈ pairs(kernels)\n        l = scatterlines!(ax, Ms, errs[:, j, k]; label = string(nameof(typeof(kernel))))\n        if kernel isa BackwardsKaiserBesselKernel  # default kernel\n            # Make sure this curve is on top\n            translate!(l, 0, 0, 10)\n        else\n            # Use an open marker for the non-default kernels\n            l.strokewidth = 1\n            l.strokecolor = l.color[]\n            l.markercolor = :transparent\n        end\n    end\n    kw_line = (linestyle = :dash, color = :grey)\n    kw_text = (color = :grey, fontsize = 12)\n    if σ ≈ 1.25\n        let xs = 3.5:11.5, ys = @. 10.0^(-0.5 * xs - 1)\n            lines!(ax, xs, ys; kw_line...)\n            text!(ax, xs[3end÷5], ys[3end÷5]; text = L\"∼10^{-0.5 M}\", align = (:right, :top), kw_text...)\n        end\n        let xs = 2.5:8.5, ys = @. 10.0^(-1.3 * xs - 0)\n            lines!(ax, xs, ys; kw_line...)\n            text!(ax, xs[3end÷5], ys[3end÷5]; text = L\"∼10^{-1.3 M}\", align = (:right, :top), kw_text...)\n        end\n    elseif σ ≈ 1.5\n        let xs = 3.5:11.5, ys = @. 10.0^(-0.7 * xs - 1)\n            lines!(ax, xs, ys; kw_line...)\n            text!(ax, xs[3end÷5], ys[3end÷5]; text = L\"∼10^{-0.7 M}\", align = (:right, :top), kw_text...)\n        end\n        let xs = 2.5:7.5, ys = @. 10.0^(-1.6 * xs - 0.5)\n            lines!(ax, xs, ys; kw_line...)\n            text!(ax, xs[3end÷4], ys[3end÷4]; text = L\"∼10^{-1.6 M}\", align = (:right, :top), kw_text...)\n        end\n    elseif σ ≈ 2.0\n        let xs = 3.5:11.5, ys = @. 10.0^(-xs - 1)\n            lines!(ax, xs, ys; kw_line...)\n            text!(ax, xs[3end÷5], ys[3end÷5]; text = L\"∼10^{-M}\", align = (:right, :top), kw_text...)\n        end\n        let xs = 2.5:6.5, ys = @. 10.0^(-2 * xs)\n            lines!(ax, xs, ys; kw_line...)\n            text!(ax, xs[3end÷5], ys[3end÷5]; text = L\"∼10^{-2M}\", align = (:right, :top), kw_text...)\n        end\n    end\n    ax\nend\nlegend_kw = (; labelsize = 10, rowgap = -4, framewidth = 0.5,)\naxislegend(axs[begin]; position = (0, 0), legend_kw...)\naxislegend(axs[end]; legend_kw...)\nlinkxaxes!(axs...)\nlinkyaxes!(axs...)\nsave(\"accuracy.svg\", fig; pt_per_unit = 2.0)\nnothing  # hide","category":"page"},{"location":"accuracy/","page":"Accuracy","title":"Accuracy","text":"(Image: NUFFT accuracy for choice of parameters.)","category":"page"},{"location":"accuracy/","page":"Accuracy","title":"Accuracy","text":"In all cases, the convergence with respect to the spreading half-width M is exponential, but the actual convergence rate depends on the chosen kernel function and on the oversampling factor σ. The straight dashed lines in the figure above are just an indication allowing to estimate the rate of exponential convergence of the different kernels as M is increased. Clearly, the BackwardsKaiserBesselKernel (default) and KaiserBesselKernel are those which display the best convergence rates and the smallest errors for a given M. Note that the evaluation of both these kernels is highly optimised using basically the same techniques originally proposed for FINUFFT (that is, an accurate piecewise polynomial approximation of the kernel function).","category":"page"},{"location":"accuracy/","page":"Accuracy","title":"Accuracy","text":"In conclusion, there is usually no reason for changing the default kernel (BackwardsKaiserBesselKernel).","category":"page"},{"location":"#NonuniformFFTs.jl","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Yet another package for computing multidimensional non-uniform fast Fourier transforms (NUFFTs) in Julia.","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Like other existing packages, computation of NUFFTs on CPU are parallelised using threads. Transforms can also be performed on GPUs. In principle all kinds of GPU for which a KernelAbstractions.jl backend exists are supported.","category":"page"},{"location":"#Installation","page":"NonuniformFFTs.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"NonuniformFFTs.jl can be simply installed from the Julia REPL with:","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"julia> ] add NonuniformFFTs","category":"page"},{"location":"#nufft-conventions","page":"NonuniformFFTs.jl","title":"Conventions","text":"","category":"section"},{"location":"#Transform-definitions","page":"NonuniformFFTs.jl","title":"Transform definitions","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"This package evaluates type-1 (non-uniform to uniform) and type-2 (uniform to non-uniform) non-uniform fast Fourier transforms (NUFFTs). These are sometimes also called the adjoint and direct NUFFTs, respectively.","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"In one dimension, the type-1 NUFFT computed by this package is defined as follows:","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"u(k) = _j = 1^M v_j  e^-i k x_j\nquad text for  quad\nk = -fracN2  fracN2 - 1","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"where the x_j  0 2π) are the non-uniform points and the v_j are the input values at those points, and k are the associated Fourier wavenumbers (or frequencies). Here M is the number of non-uniform points, and N is the number of Fourier modes that are kept (taken to be even here, but can also be odd).","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Similarly, the type-2 NUFFT is defined as:","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"v_j = _k = -N2^N2 + 1 u(k)  e^+i k x_j","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"for x_j  0 2π). The type-2 transform can be interpreted as an interpolation of a Fourier series onto a given location.","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"If the points are uniformly distributed in 0 2π), i.e. x_j = 2π (j - 1)  M, then these definitions exactly correspond to the forward and backward DFTs computed by FFTW.","category":"page"},{"location":"#Ordering-of-data-in-frequency-space","page":"NonuniformFFTs.jl","title":"Ordering of data in frequency space","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"This package follows the FFTW convention of storing frequency-space data starting from the non-negative frequencies (k = 0 1  N2 - 1), followed by the negative frequencies (k = -N2  -2 -1). Note that this package also allows the non-uniform data (v_j values) to be purely real, in which case real-to-complex FFTs are performed and only the non-negative wavenumbers are kept (in one dimension).","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"One can use the fftfreq function from the AbstractFFTs package to conveniently obtain the Fourier frequencies in the right order. For real data transforms, rfftfreq should be used instead.","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"For complex non-uniform data, one can use fftshift and ifftshift from the same package to switch between this convention and the more \"natural\" convention of storing frequencies in increasing order (k = -N2  N2 - 1).","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Alternatively, one can pass fftshift = true to the PlanNUFFT constructor to reorder Fourier modes in increasing order of frequencies (\"natural\" order).","category":"page"},{"location":"#similar-packages","page":"NonuniformFFTs.jl","title":"Differences with other packages","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"This package roughly follows the same notation and conventions of the FINUFFT library and its Julia interface, with a few differences detailed below.","category":"page"},{"location":"#Conventions-used-by-this-package","page":"NonuniformFFTs.jl","title":"Conventions used by this package","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"We try to preserve as much as possible the conventions used in FFTW3. In particular, this means that:","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"The FFT outputs are ordered starting from mode k = 0 to k = N2 - 1 (for even N) and then from -N2 to -1. Wavenumbers can be obtained in this order by calling AbstractFFTs.fftfreq(N, N). Use AbstractFFTs.fftshift to get Fourier modes in increasing order -N2  -1 0 1  N2 - 1. In FINUFFT, one should set modeord = 1 to get this order.\nThe type-1 NUFFT (non-uniform to uniform) is defined with a minus sign in the exponential. This is the same convention as the forward DFT in FFTW3. In particular, this means that performing a type-1 NUFFT on uniform points gives the same output than performing a FFT using FFTW3. In FINUFFT, this corresponds to setting iflag = -1 in type-1 transforms. Conversely, type-2 NUFFTs (uniform to non-uniform) are defined with a plus sign, equivalently to the backward DFT in FFTW3.","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"For compatibility with other packages such as NFFT.jl, these conventions are not applied when the AbstractNFFTs.jl interface is used. In this specific case, modes are assumed to be ordered in increasing order, and the opposite sign convention is used for Fourier transforms.","category":"page"},{"location":"#Unique-features","page":"NonuniformFFTs.jl","title":"Unique features","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Compared to other available packages in Julia, such as FINUFFT.jl and NFFT.jl, NonuniformFFTs.jl provides the following unique features:","category":"page"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Optimised transforms of purely real non-uniform data, by taking advantage of real-to-complex FFT implementations available in FFTW and in vendor GPU libraries.\nGeneric and fast GPU implementation, allowing to target different GPU platforms thanks to the incredible KernelAbstractions.jl package.\nUser-defined callback functions, which can help improve performance and reduce memory requirements in certain applications. These can be used to modify input and/or output data \"on the fly\" when applying a transform.","category":"page"},{"location":"#Other-differences-with-NFFT.jl","page":"NonuniformFFTs.jl","title":"Other differences with NFFT.jl","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Different convention is used: non-uniform points are expected to be in 0 2π.","category":"page"},{"location":"#Other-differences-with-FINUFFT-/-cuFINUFFT-/-FINUFFT.jl","page":"NonuniformFFTs.jl","title":"Other differences with FINUFFT / cuFINUFFT / FINUFFT.jl","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"This package is written in \"pure\" Julia (besides the FFTs themselves which rely on the FFTW3 library, via their Julia interface).\nThis package provides a generic and efficient GPU implementation thanks to KernelAbstractions.jl meaning that many kinds of GPUs are supported, including not only Nvidia GPUs but also AMD ones and possibly more.\nTransforms can be performed on arbitrary number of dimensions.\nA different smoothing kernel function is used (backwards Kaiser–Bessel kernel by default on CPUs; Kaiser–Bessel kernel on GPUs).\nIt is possible to use the same plan for type-1 and type-2 transforms, reducing memory requirements in cases where one wants to perform both.","category":"page"},{"location":"#Bibliography","page":"NonuniformFFTs.jl","title":"Bibliography","text":"","category":"section"},{"location":"","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"Shih, Y.-h.; Wright, G.; Andén, J.; Blaschke, J. and Barnett, A. H. (2021), cuFINUFFT: a load-balanced GPU library for general-purpose nonuniform FFTs, arXiv:2102.08463 [cs.DC].\n\n\n\n","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Creating-plans","page":"API","title":"Creating plans","text":"","category":"section"},{"location":"API/#NonuniformFFTs.PlanNUFFT","page":"API","title":"NonuniformFFTs.PlanNUFFT","text":"PlanNUFFT([T = ComplexF64], dims::Dims; ntransforms = Val(1), backend = CPU(), kwargs...)\n\nConstruct a plan for performing non-uniform FFTs (NUFFTs).\n\nThe created plan contains all data needed to perform NUFFTs for non-uniform data of type T (ComplexF64 by default) and uniform data with dimensions dims.\n\nExtended help\n\nOptional keyword arguments\n\nntransforms = Val(1): the number of simultaneous transforms to perform. This is useful if one wants to transform multiple scalar quantities at the same non-uniform points.\nbackend::KernelAbstractions.Backend = CPU(): corresponds to the device type where everything will be executed. This could be e.g. CUDABackend() if CUDA.jl is loaded.\n\nNUFFT parameters\n\nThe following parameters control transform accuracy. The default values give a relative accuracy of the order of 10^-7 for Float64 or ComplexF64 data.\n\nm = HalfSupport(4): the half-support of the convolution kernels. Large values increase accuracy at the cost of performance.\nσ = 2.0: NUFFT oversampling factor. Typical values are 2.0 (more accurate) and 1.25 (faster), but other values such as 1.5 should also work.\nkernel::AbstractKernel = BackwardsKaiserBesselKernel(): convolution kernel used for NUFFTs.\n\nMain performance parameters\n\nkernel_evalmode: method used for kernel evaluation. The default is FastApproximation on CPU, which will attempt to use a fast approximation method which greatly speeds up kernel evaluation. On GPUs the default is Direct, as the fast approximation method is not necessarily faster.\nblock_size: the block size (in number of elements) when using block partitioning or when sorting is enabled. This enables spatial sorting of points, even when sort_points = False() (which actually permutes point data for possibly faster memory accesses). The block size can be tuned for maximal performance. It can either be passed as an Int (linear block size) or as a tuple (B₁, …, Bₙ) to specify the block size in each Cartesian direction. The current default is 4096 on the CPU and around 1024 on the GPU (but depends on the number of dimensions). These may change in the future or even depend on the actual computing device. On the CPU, using block partitioning is required for running with multiple threads. On the GPU, this option is ignored if gpu_method = :shared_memory. Blocking / spatial sorting can be completely disabled by passing block_size = nothing (but this is generally slower).\ngpu_method: allows to select between different implementations of GPU transforms. Possible options are:\n:global_memory (default): directly read and write onto arrays in global memory in spreading (type-1) and interpolation (type-2) operations;\n:shared_memory: copy data between global memory and shared memory (local to each GPU workgroup) and perform most operations in the latter, which is faster and can help avoid some atomic operations in type-1 transforms. We try to use as much shared memory as is typically available on current GPUs (which is typically 48 KiB on CUDA and 64 KiB on AMDGPU). Note that this method completely ignores the block_size parameter, as the actual block size is adjusted to maximise shared memory usage. When this method is enabled, one can play with the gpu_batch_size parameter (see below) to further tune performance.\nFor highly dense problems (number of non-uniform points comparable to the total grid size), the :shared_memory method can be much faster, especially when the HalfSupport is 4 or less (accuracies up to 1e-7 for σ = 2).\nfftw_flags = FFTW.MEASURE: parameters passed to the FFTW planner when backend = CPU().\n\nOther performance parameters\n\nThese are more advanced performance parameters which may disappear or whose behaviour may change in the future.\n\nsort_points = False(): whether to internally permute the order of the non-uniform points. This can be enabled by passing sort_points = True(). This will generally require extra allocations since the input points need to be copied onto a new container. If this is enabled, more time will be spent in set_points! and less time on the actual transforms. This can improve performance if executing multiple transforms on the same non-uniform points. Note that, even when enabled, this does not modify the points argument passed to set_points!. This option is ignored when block_size = nothing (which disables spatial sorting).\ngpu_batch_size = Val(Np): minimum batch size used in type-1 transforms when gpu_method = :shared_memory. The idea is that, to avoid inefficient atomic operations on shared-memory arrays, we process non-uniform points in batches of Np points. The actual value of Np will typically be larger than the input one in order to maximise shared memory usage within each GPU workgroup. Note that larger Np also means that less shared memory space is available for local blocks, meaning that the effective block size can get smaller (which is not necessarily bad for performance, and can actually be beneficial). When tuning performance, it is helpful to print the plan (as in println(plan)) to see the actual block and batch sizes.\n\nOther parameters\n\nfftshift = false: determines the order of wavenumbers in uniform space. If false (default), the same order used by FFTW is used, with positive wavenumbers first ([0, 1, 2, …, N÷2-1] for even-size transforms) and negative ones afterwards ([-N÷2, …, -1]). Otherwise, wavenumbers are expected to be in increasing order ([-N÷2, -kmax, …, -1, 0, 1, …, N÷2-1]), which is compatible with the output in NFFT.jl and corresponds to applying the AbstractFFTs.fftshift function to the data. This option also corresponds to the modeord parameter in FINUFFT. This only affects complex-to-complex transforms.\ntimer = TimerOutput(): allows to specify a TimerOutput (from the TimerOutputs.jl package) where timing information will be written to. By default the plan creates its own timer. One can visualise the time spent on different parts of the NUFFT computation using p.timer.\nsynchronise = false: if true, add synchronisation barrier between calls to GPU kernels. Enabling this is needed for accurate timings in p.timer when computing on a GPU, but may result in reduced performance.\n\nFFT size and performance\n\nFor performance reasons, when doing FFTs one usually wants the size of the input along each dimension to be a power of 2 (ideally), or the product of powers of small prime numbers (2, 3, 5, …). The problem is that, with the NUFFT, one does not directly control the FFT size due to the oversampling factor σ, which may be any real number σ  1. That is, for an input of size N, FFTs are performed on an oversampled grid of size Ñ  σN. Note that σN is generally not an integer, hence the .\n\nThe aim of this section is to clarify how Ñ is actually chosen, so that one can predict its value for given inputs N and σ. This may be better understood in actual code:\n\nÑ = nextprod((2, 3, 5), floor(Int, σ * N))\n\nBasically, we truncate σN to an integer, and then we choose Ñ as the next integer that can be written as the product of powers of 2, 3 and 5 (see nextprod). Most often, the result will be greater than or equal to σN.\n\nUsing real non-uniform data\n\nIn some applications, the non-uniform data to be transformed is purely real. In this case, one may pass Float64 or Float32 as the first argument. This may be faster than converting data to complex types, in particular because the real-to-complex FFTs from FFTW will be used to compute the transforms. Note that, in this case, the dimensions of the uniform data arrays is not exactly dims, since the size of the first dimension is divided roughly by 2 (taking advantage of Hermitian symmetry). For convenience, one can call size(::PlanNUFFT) on the constructed plan to know in advance the dimensions of the uniform data arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.NFFTPlan","page":"API","title":"NonuniformFFTs.NFFTPlan","text":"NonuniformFFTs.NFFTPlan(xp::AbstractMatrix{T}, dims::Dims{D}; kwargs...) -> plan\n\nCreate a NUFFT plan which is compatible with the AbstractNFFTs.jl interface.\n\nThe plan follows different rules from plans created by PlanNUFFT. In particular:\n\npoints are assumed to be in -12 12) instead of 0 2π);\nthe opposite Fourier sign convention is used (e.g. e^-i k x_j becomes e^+2π i k x_j);\nuniform data is in increasing order by default, with frequencies k = -N2  -1 0 1  N2-1, as opposed to preserving the order used by FFTW (which starts at k = 0);\nit only supports complex non-uniform data.\n\nThis constructor requires passing the non-uniform locations xp as the first argument. These should be given as a matrix of dimensions (D, Np), where D is the spatial dimension and Np the number of non-uniform points.\n\nThe second argument is simply the size (N₁, N₂, …) of the uniform data arrays.\n\nMost keyword arguments from PlanNUFFT are also accepted here. Moreover, for compatibility reasons, most keyword arguments from the NFFT.jl package are also accepted as detailed below.\n\nThis type of plan can also be created via the AbstractNFFTs.plan_nfft function.\n\nThis constructor creates a plan which assumes complex-valued non-uniform data. For real-valued data, the PlanNUFFT constructor should be used instead.\n\nCompatibility with NFFT.jl\n\nMost of the parameters supported by the NFFT.jl package are also supported by this constructor. The currently supported parameters are reltol, m, σ, window, blocking, sortNodes and fftflags.\n\nMoreover, unlike PlanNUFFT, this constructor sets fftshift = true by default (but can be overridden) so that the uniform data ordering is the same as in NFFT.jl.\n\nwarning: Type instability\nExplicitly passing some of these parameters may result in type-unstable code, since the exact type of the returned plan cannot be inferred. This is because, in NonuniformFFTs.jl, parameters such as the kernel size (m) or the convolution window (window) are included in the plan type (they are compile-time constants).\n\nGPU usage\n\nTo create a GPU-compatible plan, simply pass the locations xp as a GPU array (e.g. a CuArray in CUDA). Unlike PlanNUFFT, the backend argument is not needed here and will be simply ignored.\n\n\n\n\n\n","category":"type"},{"location":"API/#Setting-non-uniform-points","page":"API","title":"Setting non-uniform points","text":"","category":"section"},{"location":"API/#NonuniformFFTs.set_points!","page":"API","title":"NonuniformFFTs.set_points!","text":"set_points!(p::PlanNUFFT, points)\n\nSet non-uniform points before executing a NUFFT.\n\nIn one dimension, points is simply a vector of real values (the non-uniform locations).\n\nIn multiple dimensions, points may be passed as:\n\na tuple of vectors (xs::AbstractVector, ys::AbstractVector, …) (should be preferred);\na vector [x⃗₁, x⃗₂, x⃗₃, x⃗₄, …] of tuples or static vectors (typically SVectors from the StaticArrays.jl package);\na matrix of size (d, Np) where d is the spatial dimension and Np the number of non-uniform points.\n\nThe first format should be preferred if one wants to avoid extra allocations.\n\nFor convenience (and backwards compatibility), one can also pass a StructVector from the StructArrays.jl package, which is equivalent to the first option above.\n\nThe points are allowed to be outside of the periodic cell 0 2π)^d, in which case they will be \"folded\" to that domain.\n\nnote: Modifying the points arrays\nAs one may expect, this package does not modify the input points, as doing this would be surprising. However, to avoid allocations and copies, it keeps a reference to the point data when performing the transforms. This means that one should not modify the passed arrays between a call to set_points! and exec_type1! or exec_type2!, as this can lead to wrong results or much worse.\n\n\n\n\n\n","category":"function"},{"location":"API/#Executing-plans","page":"API","title":"Executing plans","text":"","category":"section"},{"location":"API/#NonuniformFFTs.exec_type1!","page":"API","title":"NonuniformFFTs.exec_type1!","text":"exec_type1!(ûs::AbstractArray{Z}, p::PlanNUFFT{T}, vp::AbstractVector{T}; callbacks = NUFFTCallbacks())\nexec_type1!(ûs::NTuple{N,AbstractArray{Z}}, p::PlanNUFFT{T}, vp::NTuple{N,AbstractVector{T}}; callbacks = NUFFTCallbacks())\n\nPerform type-1 NUFFT (from non-uniform points to uniform grid).\n\nHere vp contains the input values at non-uniform points. The result of the transform is written into ûs.\n\nOne first needs to set the non-uniform points using set_points!.\n\nTo perform multiple transforms at once, both vp and ûs should be a tuple of arrays (second variant above). Note that this requires a plan initialised with ntransforms = Val(N) (see PlanNUFFT).\n\nThe input types must satisfy Z = complex(T). This means:\n\nZ = Complex{T} for real-data transforms (where T <: Real);\nZ = T for complex-data transforms (where T <: Complex).\n\nSee NUFFTCallbacks for details on the optional callbacks keyword argument.\n\nSee also exec_type2!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NonuniformFFTs.exec_type2!","page":"API","title":"NonuniformFFTs.exec_type2!","text":"exec_type2!(vp::AbstractVector{T}, p::PlanNUFFT{T}, ûs::AbstractArray{Z}; callbacks = NUFFTCallbacks())\nexec_type2!(vp::NTuple{N,AbstractVector{T}}, p::PlanNUFFT{T}, ûs::NTuple{N,AbstractArray{Z}}; callbacks = NUFFTCallbacks())\n\nPerform type-2 NUFFT (from uniform grid to non-uniform points).\n\nHere ûs contains the input coefficients in the uniform grid. The result of the transform at non-uniform points is written into vp.\n\nOne first needs to set the non-uniform points using set_points!.\n\nTo perform multiple transforms at once, both vp and ûs should be a tuple of arrays (second variant above). Note that this requires a plan initialised with ntransforms = Val(N) (see PlanNUFFT).\n\nThe input types must satisfy Z = complex(T). This means:\n\nZ = Complex{T} for real-data transforms (where T <: Real);\nZ = T for complex-data transforms (where T <: Complex).\n\nSee NUFFTCallbacks for details on the optional callbacks keyword argument.\n\nSee also exec_type1!.\n\n\n\n\n\n","category":"function"},{"location":"API/#Using-callbacks","page":"API","title":"Using callbacks","text":"","category":"section"},{"location":"API/#NonuniformFFTs.NUFFTCallbacks","page":"API","title":"NonuniformFFTs.NUFFTCallbacks","text":"NUFFTCallbacks(; nonuniform, uniform,)\n\nOptional callback functions to be applied at different stages of a NUFFT.\n\nThese are user-defined functions that allow to modify \"on the fly\" the input and/or the output of a NUFFT (type 1 or 2).\n\nThis can be useful for performance (as it allows to combine operations and reduce the number of passes through memory) and for reducing memory usage (avoiding allocation of new arrays). Note that transform inputs are never modified by the callback, which means that one can safely do further operations on the original input data after the transform.\n\nCallbacks defined via NUFFTCallbacks are accepted by exec_type1! and exec_type2! via their callbacks keyword argument.\n\nCallback types\n\nOne can define two types of callback functions:\n\na callback on non-uniform data (input of type-1 NUFFT / output of type-2 NUFFT).\nIts signature should be nonuniform(v::Tuple, n::Integer), where v = (v₁, v₂, …) is the  \"original\" value at the non-uniform point with index n (i.e. in the points array of set_points!).\nNote: the length of v is equal to the number of transforms (ntransforms argument of PlanNUFFT).\na callback on uniform data (output of type-1 NUFFT / input of type-2 NUFFT).\nIts signature should be uniform(w::Tuple, idx::Tuple), where w = (w₁, w₂, …) is  the \"original\" value at grid point with index idx = (i₁, i₂, …). Note that w and idx  are tuples which may have different lengths:\nthe length of w is equal to the number of transforms (ntransforms argument of PlanNUFFT);\nthe length of idx is equal to the number of dimensions (e.g. 3 for 3D transforms).\n\nwarning: Output type\nOne must make sure that the value returned by the callback has the same type as the input. For instance, if uniform data has type ComplexF32, then values returned by uniform must also be ComplexF32. One may use oftype to ensure this (see examples below).\n\nExamples\n\nCallback on non-uniform data\n\nDefine a callback function that multiplies each non-uniform point by random weights in 2D:\n\nNp = 1000                                # number of non-uniform points\nxs = (rand(Np) .* 2pi, rand(Np) .* 2pi)  # random non-uniform points in [0, 2π]²\nweights = rand(Np)                       # random weights\n\ncallback_nu(v, n) = oftype(v, v .* weights[n])   # define callback which will multiply each non-uniform value by its corresponding weight\ncallbacks = NUFFTCallbacks(nonuniform = callback_nu)\n\nexec_type1!(output, plan, input; callbacks = callbacks)  # use callback in type-1 transform (for example)\n\nCallback on uniform data\n\nDefine a callback function that multiplies each uniform point by bmk^2 (where bmk can represent a Fourier wavevector):\n\nusing AbstractFFTs: fftfreq\nNx = Ny = 256                    # dimensions of uniform grid\nws = rand(ComplexF64, (Nx, Ny))  # random non-uniform data\nkx = fftfreq(Nx, Nx)             # wavenumbers (frequencies) in x direction\nky = fftfreq(Ny, Ny)             # wavenumbers (frequencies) in y direction\n\nfunction callback_u(w, idx)\n    i, j = idx\n    k² = kx[i]^2 + ky[j]^2\n    oftype(w, w .* k²)\nend\n\ncallbacks = NUFFTCallbacks(uniform = callback_u)\n\nexec_type1!(output, plan, input; callbacks = callbacks)  # use callback in type-1 transform (for example)\n\n\n\n\n\n","category":"type"},{"location":"API/#Other-functions","page":"API","title":"Other functions","text":"","category":"section"},{"location":"API/#Base.size-Tuple{PlanNUFFT}","page":"API","title":"Base.size","text":"size(p::PlanNUFFT) -> (N₁, N₂, ...)\n\nReturn the dimensions of arrays containing uniform values.\n\nThis corresponds to the number of Fourier modes in each direction (in the non-oversampled grid).\n\n\n\n\n\n","category":"method"},{"location":"API/#Available-kernel-functions","page":"API","title":"Available kernel functions","text":"","category":"section"},{"location":"API/#NonuniformFFTs.Kernels.KaiserBesselKernel","page":"API","title":"NonuniformFFTs.Kernels.KaiserBesselKernel","text":"KaiserBesselKernel <: AbstractKernel\nKaiserBesselKernel([β])\n\nRepresents a Kaiser–Bessel spreading kernel.\n\nDefinition\n\nϕ(x) = I₀ left(β sqrt1 - x² right)\nquad text for  x  1\n\nwhere I₀ is the zeroth-order modified Bessel function of the first kind and β is a shape factor.\n\nFourier transform\n\nϕ(k) = 2 fracsinhleft( sqrtβ² - k² right)sqrtβ² - k²\n\nParameter selection\n\nBy default, the shape parameter is chosen to be [1]\n\nβ = γ M π left( 2 - frac1σ right)\n\nwhere M is the kernel half-width and σ the oversampling factor. Moreover, γ = 0980 is an empirical \"safety factor\", similarly to the one used by FINUFFT [2], which slightly improves accuracy.\n\nThis default value can be overriden by explicitly passing a β value.\n\nImplementation details\n\nSince the evaluation of Bessel functions can be costly, this kernel is efficiently evaluated via an accurate piecewise polynomial approximation. We use the same method originally proposed for FINUFFT [2] and later discussed by Shamshirgar et al. [3].\n\n[1] Potts & Steidl, SIAM J. Sci. Comput. 24, 2013 (2003) \n[2] Barnett, Magland & af Klinteberg, SIAM J. Sci. Comput. 41, C479 (2019) \n[3] Shamshirgar, Bagge & Tornberg, J. Chem. Phys. 154, 164109 (2021)\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.BackwardsKaiserBesselKernel","page":"API","title":"NonuniformFFTs.Kernels.BackwardsKaiserBesselKernel","text":"BackwardsKaiserBesselKernel <: AbstractKernel\nBackwardsKaiserBesselKernel([β])\n\nRepresents a backwards Kaiser–Bessel (KB) spreading kernel.\n\nThis kernel basically results from swapping the KaiserBesselKernel spreading function and its Fourier transform. It has very similar properties to the Kaiser–Bessel kernel.\n\nDefinition\n\nϕ(x) = fracsinh left(β sqrt1 - x² right)π sqrt1 - x²\nquad text for  x  1\n\nwhere β is a shape factor.\n\nFourier transform\n\nϕ(k) = I₀ left( sqrtβ² - k² right)\n\nwhere I₀ is the zeroth-order modified Bessel function of the first kind.\n\nParameter selection\n\nBy default, the shape parameter is chosen to be [1]\n\nβ = γ M π left( 2 - frac1σ right)\n\nwhere M is the kernel half-width and σ the oversampling factor. Moreover, γ = 0995 is an empirical \"safety factor\", similarly to the one used by FINUFFT [2], which slightly improves accuracy.\n\nThis default value can be overriden by explicitly passing a β value.\n\nImplementation details\n\nSince the evaluation of the hyperbolic sine functions can be costly, this kernel is efficiently evaluated via an accurate piecewise polynomial approximation. We use the same method originally proposed for FINUFFT [2] and later discussed by Shamshirgar et al. [3].\n\n[1] Potts & Steidl, SIAM J. Sci. Comput. 24, 2013 (2003) \n[2] Barnett, Magland & af Klinteberg, SIAM J. Sci. Comput. 41, C479 (2019) \n[3] Shamshirgar, Bagge & Tornberg, J. Chem. Phys. 154, 164109 (2021)\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.GaussianKernel","page":"API","title":"NonuniformFFTs.Kernels.GaussianKernel","text":"GaussianKernel <: AbstractKernel\nGaussianKernel([ℓ/Δx])\n\nRepresents a truncated Gaussian spreading kernel.\n\nDefinition\n\nϕ(x) = e^-x²  2ℓ²\n\nwhere ℓ is the characteristic width of the kernel.\n\nFourier transform\n\nϕ(k) = sqrt2πℓ² e^-ℓ² k²  2\n\nParameter selection\n\nBy default, given a kernel half-width M, an oversampling factor σ and the oversampling grid spacing Δx, the characteristic width ℓ is chosen as [1]\n\nℓ² = Δx² fracσ2σ - 1 fracMπ\n\nThis default value can be overriden by explicitly passing a value of the wanted normalised width ℓΔx.\n\nImplementation details\n\nIn the implementation, this kernel is efficiently evaluated using the fast Gaussian gridding method proposed by Greengard & Lee [2].\n\n[1] Potts & Steidl, SIAM J. Sci. Comput. 24, 2013 (2003) \n[2] Greengard & Lee, SIAM Rev. 46, 443 (2004)\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.BSplineKernel","page":"API","title":"NonuniformFFTs.Kernels.BSplineKernel","text":"BSplineKernel <: AbstractKernel\nBSplineKernel()\n\nRepresents a B-spline spreading kernel.\n\nThe order n of the B-spline is directly related to the kernel half-width M by n = 2M (the polynomial degree is n - 1).\n\nDefinition\n\nA B-spline of order n may be defined via its Fourier transform:\n\nϕ(k) = Δx operatornamesinc^n left( frack Δx2 right)\n\nwhere Δx is the spacing of the oversampled grid and operatornamesinc is the unnormalised sinc function.\n\nImplementation details\n\nIn the implementation, this kernel is evaluated using de Boor's algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API/#Kernel-evaluation-methods","page":"API","title":"Kernel evaluation methods","text":"","category":"section"},{"location":"API/#NonuniformFFTs.Kernels.Direct","page":"API","title":"NonuniformFFTs.Kernels.Direct","text":"Direct <: Kernels.EvaluationMode\n\nDirectly evaluate kernels using their definition.\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.FastApproximation","page":"API","title":"NonuniformFFTs.Kernels.FastApproximation","text":"FastApproximation <: Kernels.EvaluationMode\n\nUse a fast approximation or algorithm to efficiently evaluate a kernel.\n\nThe evaluation type depends on the actual kernel:\n\nfor KaiserBesselKernel and BackwardsKaiserBesselKernel, this uses a fast piecewise polynomial approximation heavily inspired from FINUFFT;\nfor GaussianKernel, this uses the fast Gaussian gridding algorithm proposed by Greengard & Lee (SIAM Rev. 2004);\nfor BSplineKernel, this is currently the same as Direct evaluation.\n\nIn the first two cases, this is generally faster than Direct evaluation for CPU transforms.\n\nOn GPUs this is not necessarily the case, and results may depend on the actual GPU used. For example, on an Nvidia A100, Direct evaluation of the KaiserBesselKernel (which involves Bessel functions) seems to beat polynomial approximation, and is also a bit faster than the BackwardsKaiserBesselKernel (involving sinh functions).\n\n\n\n\n\n","category":"type"},{"location":"API/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"API/#NonuniformFFTs.spread_from_point!","page":"API","title":"NonuniformFFTs.spread_from_point!","text":"spread_from_point!(gs::NTuple{D, AbstractKernelData}, evalmode::EvaluationMode, u::AbstractArray{T, D}, x⃗₀, v)\n\nSpread value v at point x⃗₀ onto neighbouring grid points.\n\nThe grid is assumed to be periodic with period 2π in each direction.\n\nThe point x⃗₀ must be in 0 2π)^D. It may be given as a tuple x⃗₀ = (x₀, y₀, …) or similarly as a static vector (from StaticArrays.jl).\n\nOne can also pass tuples v = (v₁, v₂, …) and u = (u₁, u₂, …), in which case each value vᵢ will be spread to its corresponding array uᵢ. This can be useful for spreading vector fields, for instance.\n\n\n\n\n\n","category":"function"},{"location":"API/#NonuniformFFTs.ntransforms","page":"API","title":"NonuniformFFTs.ntransforms","text":"ntransforms(p::PlanNUFFT) -> Int\n\nReturn the number of datasets which are simultaneously transformed by a plan.\n\n\n\n\n\n","category":"function"},{"location":"API/#Kernel-functions","page":"API","title":"Kernel functions","text":"","category":"section"},{"location":"API/#NonuniformFFTs.Kernels.AbstractKernel","page":"API","title":"NonuniformFFTs.Kernels.AbstractKernel","text":"AbstractKernel\n\nAbstract type representing a smoothing kernel function.\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.AbstractKernelData","page":"API","title":"NonuniformFFTs.Kernels.AbstractKernelData","text":"AbstractKernelData{K <: AbstractKernel, M, T}\n\nAbstract type representing an object which contains data associated to a kernel.\n\nType parameters are a smoothing kernel K with half-support M (an integer value) and element type T.\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.KaiserBesselKernelData","page":"API","title":"NonuniformFFTs.Kernels.KaiserBesselKernelData","text":"KaiserBesselKernelData(HalfSupport(M), Δx, β)\n\nCreate a Kaiser–Bessel kernel.\n\nThe kernel parameters are:\n\nM: the half-support of the kernel (an integer value);\nΔx: the spacing of the (oversampled) grid;\nβ: the Kaiser–Bessel shape parameter.\n\nHere the half-kernel size in \"physical\" units is w = M Δx. This means that if we want to evaluate the kernel around a source location x, then the evaluation points will be in x - w x + w).\n\nMore precisely, the evaluation points will be x_i = x - δ + i Δx, where the point x_0 = x - δ is the nearest point to the left of x which is on the grid (that is, 0  δ  Δx), and i  left-M -M + 1  M - 2 M - 1 right.\n\nOptimal shape parameter β\n\nFor the purposes of computing NUFFTs, the optimal shape parameter is\n\nβ = M π left( 2 - frac1σ right)\n\nwhere σ  1 is the NUFFT oversampling parameter. See for instance Potts & Steidl, SIAM J. Sci. Comput. 2003, eq. (5.12). In other words, FFTs must be performed over a grid of size Ñ = σN where N is the size of the grid of interest.\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.GaussianKernelData","page":"API","title":"NonuniformFFTs.Kernels.GaussianKernelData","text":"GaussianKernelData(HalfSupport(M), Δx, α)\n\nConstructs a Gaussian kernel with standard deviation σ = α Δx and half-support M, for a grid of step Δx.\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.BSplineKernelData","page":"API","title":"NonuniformFFTs.Kernels.BSplineKernelData","text":"BSplineKernelData(HalfSupport(M), Δx)\n\nConstructs a B-spline kernel with half-support M for a grid of step Δx.\n\nThe B-spline order is simply n = 2M. Note that the polynomial degree is n - 1. In other words, setting M = 2 corresponds to cubic B-splines.\n\nFor performance reasons, the separation Δt between B-spline knots is set to be equal to the grid step Δx. This means that the resulting variance of the B-spline kernels is fixed to σ^2 = (n  12) Δt^2 = (M  6) Δx^2.\n\n\n\n\n\n","category":"type"},{"location":"API/#NonuniformFFTs.Kernels.half_support","page":"API","title":"NonuniformFFTs.Kernels.half_support","text":"half_support(g::AbstractKernelData{K, M}) -> M\n\nReturns the half-support M of the kernel.\n\nThis is half the number of grid points where the kernel is evaluated at each convolution.\n\n\n\n\n\n","category":"function"},{"location":"API/#NonuniformFFTs.Kernels.order","page":"API","title":"NonuniformFFTs.Kernels.order","text":"order(::BSplineKernelData{M})\n\nReturns the order n = 2M of the B-spline kernel.\n\nNote: the polynomial degree is n - 1.\n\n\n\n\n\n","category":"function"},{"location":"API/#NonuniformFFTs.Kernels.init_fourier_coefficients!","page":"API","title":"NonuniformFFTs.Kernels.init_fourier_coefficients!","text":"init_fourier_coefficients!(g::AbstractKernelData, ks::AbstractVector) -> AbstractVector\n\nPrecompute Fourier coefficients associated to kernel g at wavenumbers ks.\n\nReturns a vector with the computed coefficients.\n\nIf the coefficient vector was already computed in a previous call, then this function just returns the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"API/#NonuniformFFTs.Kernels.fourier_coefficients","page":"API","title":"NonuniformFFTs.Kernels.fourier_coefficients","text":"fourier_coefficients(g::AbstractKernelData) -> AbstractVector\n\nReturns vector with Fourier coefficients associated to the kernel.\n\nThe Fourier coefficients must first be precomputed at the chosen wavenumbers using init_fourier_coefficients!. Otherwise, this just returns an empty vector.\n\n\n\n\n\n","category":"function"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]","category":"page"}]
}
