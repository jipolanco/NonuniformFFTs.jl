var documenterSearchIndex = {"docs":
[{"location":"#NonuniformFFTs.jl","page":"NonuniformFFTs.jl","title":"NonuniformFFTs.jl","text":"","category":"section"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CurrentModule = NonuniformFFTs","category":"page"},{"location":"API/#Creating-plans","page":"API","title":"Creating plans","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"PlanNUFFT","category":"page"},{"location":"API/#NonuniformFFTs.PlanNUFFT","page":"API","title":"NonuniformFFTs.PlanNUFFT","text":"PlanNUFFT([T = ComplexF64], dims::Dims; ntransforms = Val(1), kwargs...)\n\nConstruct a plan for performing non-uniform FFTs (NUFFTs).\n\nThe created plan contains all data needed to perform NUFFTs for non-uniform data of type T (ComplexF64 by default) and uniform data with dimensions dims.\n\nOptional keyword arguments\n\nntransforms = Val(1): the number of simultaneous transforms to perform. This is useful if one wants to transform multiple scalar quantities at the same non-uniform points.\n\nNUFFT parameters\n\nm = HalfSupport(8): the half-support of the convolution kernels. Large values increase accuracy at the cost of performance.\nσ = 2.0: NUFFT oversampling factor. Typical values are 2.0 (more accurate) and 1.25 (faster), but other values such as 1.5 should also work.\nkernel::AbstractKernel = BackwardsKaiserBesselKernel(): convolution kernel used for NUFFTs.\n\nPerformance parameters\n\nblock_size = 4096: the linear block size (in number of elements) when using block partitioning. This can be tuned for maximal performance. Blocking can be completely disabled by passing block_size = nothing (but this is generally slower).\n\nOther parameters\n\nfftw_flags = FFTW.MEASURE: parameters passed to the FFTW planner.\ntimer = TimerOutput(): allows to specify a TimerOutput (from the TimerOutputs.jl package) where timing information will be written to. By default the plan creates its own timer. One can visualise the time spent on different parts of the NUFFT computation using p.timer.\n\nUsing real non-uniform data\n\nIn some applications, the non-uniform data to be transformed is purely real. In this case, one may pass Float64 or Float32 as the first argument. This may be faster than converting data to complex types, in particular because the real-to-complex FFTs from FFTW will be used to compute the transforms. Note that, in this case, the dimensions of the uniform data arrays is not exactly dims, since the size of the first dimension is divided roughly by 2 (taking advantage of Hermitian symmetry). For convenience, one can call size(::PlanNUFFT) on the constructed plan to know in advance the dimensions of the uniform data arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#Setting-non-uniform-points","page":"API","title":"Setting non-uniform points","text":"","category":"section"},{"location":"API/#Executing-plans","page":"API","title":"Executing plans","text":"","category":"section"},{"location":"API/#Other-functions","page":"API","title":"Other functions","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"size(::PlanNUFFT)","category":"page"},{"location":"API/#Base.size-Tuple{PlanNUFFT}","page":"API","title":"Base.size","text":"size(p::PlanNUFFT) -> (N₁, N₂, ...)\n\nReturn the dimensions of arrays containing uniform values.\n\nThis corresponds to the number of Fourier modes in each direction (in the non-oversampled grid).\n\n\n\n\n\n","category":"method"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"NUFFT.md\"]","category":"page"}]
}
